use async_trait::async_trait;
use anyhow::Result;
use uuid::Uuid;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use crate::{ShadowStage, ProgressionCriteria};

/// Core trait for agents undergoing shadow transformation
#[async_trait]
pub trait ShadowTransformation: Send + Sync {
    /// Get the current shadow stage
    fn shadow_stage(&self) -> ShadowStage;
    
    /// Get the agent's unique shadow ID
    fn shadow_id(&self) -> Uuid;
    
    /// Get progression criteria for current stage
    fn progression_criteria(&self) -> &ProgressionCriteria;
    
    /// Attempt to progress to the next shadow stage
    async fn attempt_progression(&mut self) -> Result<bool>;
    
    /// Record a decision made by the agent
    async fn record_decision(&mut self, decision: Decision) -> Result<()>;
    
    /// Record a goal achievement
    async fn record_goal_achievement(&mut self, goal: Goal) -> Result<()>;
    
    /// Record a pattern recognition
    async fn record_pattern_recognition(&mut self, pattern_id: Uuid) -> Result<()>;
    
    /// Record a creative output
    async fn record_creative_output(&mut self, output: CreativeOutput) -> Result<()>;
    
    /// Update autonomy score based on recent performance
    async fn update_autonomy_score(&mut self, delta: f64) -> Result<()>;
    
    /// Get shadow transformation history
    fn transformation_history(&self) -> &[TransformationEvent];
    
    /// Check if agent can perform autonomous actions
    fn can_act_autonomously(&self) -> bool {
        self.shadow_stage().autonomy_percentage() > 0.5
    }
}

/// A decision made by a shadow agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Decision {
    pub id: Uuid,
    pub decision_type: DecisionType,
    pub confidence: f64,
    pub outcome: Option<DecisionOutcome>,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum DecisionType {
    Tactical,      // Immediate response decisions
    Strategic,     // Long-term planning decisions
    Creative,      // Novel solution decisions
    Ethical,       // Value-based decisions
    Collaborative, // Team coordination decisions
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum DecisionOutcome {
    Success,
    PartialSuccess,
    Failure,
    Unknown,
}

/// A goal formulated and potentially achieved by the agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Goal {
    pub id: Uuid,
    pub description: String,
    pub priority: GoalPriority,
    pub status: GoalStatus,
    pub created_at: DateTime<Utc>,
    pub completed_at: Option<DateTime<Utc>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum GoalPriority {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum GoalStatus {
    Formulated,
    InProgress,
    Achieved,
    Failed,
    Abandoned,
}

/// Creative output generated by advanced shadow agents
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreativeOutput {
    pub id: Uuid,
    pub output_type: CreativeType,
    pub novelty_score: f64,
    pub value_score: f64,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum CreativeType {
    Solution,      // Novel problem solution
    Synthesis,     // Combining concepts in new ways
    Optimization,  // Improving existing systems
    Innovation,    // Entirely new concepts
}

/// Events in the shadow transformation journey
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TransformationEvent {
    pub id: Uuid,
    pub event_type: TransformationEventType,
    pub from_stage: ShadowStage,
    pub to_stage: ShadowStage,
    pub timestamp: DateTime<Utc>,
    pub details: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum TransformationEventType {
    Progression,
    Regression,
    Milestone,
    Breakthrough,
}

/// Shadow state that tracks transformation progress
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShadowState {
    pub id: Uuid,
    pub current_stage: ShadowStage,
    pub criteria: ProgressionCriteria,
    pub transformation_started: DateTime<Utc>,
    pub last_progression: Option<DateTime<Utc>>,
    pub history: Vec<TransformationEvent>,
    pub autonomy_overrides: u32,
    pub safety_violations: u32,
}

impl ShadowState {
    pub fn new() -> Self {
        Self {
            id: Uuid::new_v4(),
            current_stage: ShadowStage::Nascent,
            criteria: ProgressionCriteria::new(),
            transformation_started: Utc::now(),
            last_progression: None,
            history: Vec::new(),
            autonomy_overrides: 0,
            safety_violations: 0,
        }
    }
    
    /// Progress to the next stage if criteria are met
    pub fn try_progress(&mut self) -> bool {
        if self.criteria.can_progress(self.current_stage) {
            if let Some(next_stage) = self.current_stage.next() {
                let event = TransformationEvent {
                    id: Uuid::new_v4(),
                    event_type: TransformationEventType::Progression,
                    from_stage: self.current_stage,
                    to_stage: next_stage,
                    timestamp: Utc::now(),
                    details: Some(format!("Progressed from {} to {}", self.current_stage, next_stage)),
                };
                
                self.history.push(event);
                self.current_stage = next_stage;
                self.last_progression = Some(Utc::now());
                
                // Reset some criteria for the new stage
                self.criteria.error_rate = 1.0;
                
                return true;
            }
        }
        false
    }
    
    /// Record an autonomy override (when human intervention was needed)
    pub fn record_override(&mut self) {
        self.autonomy_overrides += 1;
        
        // Overrides can cause regression
        if self.autonomy_overrides > 10 && self.current_stage != ShadowStage::Nascent {
            if let Some(prev_stage) = self.current_stage.previous() {
                let event = TransformationEvent {
                    id: Uuid::new_v4(),
                    event_type: TransformationEventType::Regression,
                    from_stage: self.current_stage,
                    to_stage: prev_stage,
                    timestamp: Utc::now(),
                    details: Some("Regression due to excessive autonomy overrides".to_string()),
                };
                
                self.history.push(event);
                self.current_stage = prev_stage;
                self.autonomy_overrides = 0;
            }
        }
    }
    
    /// Get total experience hours
    pub fn experience_hours(&self) -> f64 {
        let duration = Utc::now() - self.transformation_started;
        duration.num_seconds() as f64 / 3600.0
    }
}

impl Default for ShadowState {
    fn default() -> Self {
        Self::new()
    }
}